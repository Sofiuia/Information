
/*Нестатичні змінні-члени класу ті, що належать конкретному об'єкту зазвичай ініціалізуються в конструкторах. 
Однак у C++11 з’явилася можливість задавати значення за замовчуванням безпосередньо в оголошенні змінних.
Це допомагає уникнути дублювання коду в конструкторах, особливо якщо значення за замовчуванням використовуються в кількох місцях.
Приклад ініціалізації нестатичних змінних за замовчуванням*/
#include <iostream>

class Something {
private:
    double m_length = 3.5;  // Значення за замовчуванням
    double m_width = 3.5;   // Значення за замовчуванням

public:
    Something() {  
        // Використовуються значення за замовчуванням
    }

    void print() {
        std::cout << "length: " << m_length << " and width: " << m_width << '\n';
    }
};

int main() {
    Something a;  // m_length = 3.5, m_width = 3.5
    a.print();
    return 0;
}

//Якщо в класі задані значення за замовчуванням, але конструктор використовує список ініціалізації, то пріоритет має конструктор.

#include <iostream>

class Something {
private:
    double m_length = 3.5;  // Значення за замовчуванням
    double m_width = 3.5;   // Значення за замовчуванням

public:
    Something(double length, double width) : m_length(length), m_width(width) { }

    void print() {
        std::cout << "length: " << m_length << " and width: " << m_width << '\n';
    }
};

int main() {
    Something a(4.5, 5.5);  // Передаємо значення в конструктор
    a.print();
    return 0;
}
//C++11 дозволяє ініціалізувати нестатичні змінні напряму. Це зручно, якщо значення за замовчуванням мають бути однаковими для всіх об'єктів.
//Якщо є значення за замовчуванням, але в класі немає конструктора за замовчуванням, то створення об'єкта без параметрів буде неможливим.
//Конструктор має вищий пріоритет, ніж значення за замовчуванням. Якщо в списку ініціалізації вказані значення, вони перезапишуть ті, що задані у класі.
//Якщо значення за замовчуванням зміниться, його не треба міняти в кожному конструкторі – це робить код чистішим і легшим для підтримк